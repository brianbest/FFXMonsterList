Engineering the Temporal Battlefield: A Comprehensive Systems Analysis of Conditional Turn-Based (CTB) Architectures and Hybrid Real-Time IntegrationExecutive SummaryThe landscape of Role-Playing Game (RPG) combat mechanics has long been defined by the tension between turn-based strategy and real-time action. The Conditional Turn-Based (CTB) system, first popularized by Final Fantasy X (FFX) and recently evolved in Clair Obscur: Expedition 33 (Expedition 33), represents a sophisticated solution to this dichotomy. Unlike Active Time Battle (ATB) systems, which simulate continuous time pressure, or traditional round-based systems that enforce rigid turn alternations, CTB operates on a discrete event simulation model. This architecture treats time as a flexible resource, allowing the frequency of character actions to vary dynamically based on statistical attributes and action costs.This report provides an exhaustive technical analysis and implementation guide for the CTB system. It deconstructs the mathematical models governing the FFX timeline, including Agility-to-Tick-Speed conversion, Action Rank formulas, and the handling of temporal status effects. Furthermore, it analyzes the modernization of this framework in Expedition 33, which introduces real-time reactive elements—such as parries, dodges, and rhythm-based counters—into the deterministic CTB backbone. The following sections serve as a technology-agnostic blueprint for systems engineers and game designers aiming to reconstruct, tune, and innovate upon this "Chrono-Strategic" architecture.Part I: The Theoretical Framework of Discrete Time CombatTo engineer a Conditional Turn-Based system, one must first discard the notion of "rounds." In systems like Dungeons & Dragons or early Final Fantasy titles, a round constitutes a complete cycle where every participant acts once. In CTB, the concept of a round does not exist. Instead, the battle is a linear timeline of "Ticks," the fundamental atomic unit of time in the engine.1.1 The Continuous Tick Stream vs. RoundsIn a CTB simulation, every participant (actor) is assigned a variable, historically termed the Counter (or Action Gauge). This Counter represents the "distance" in time until the actor’s next turn. The simulation loop operates by identifying the actor with the lowest Counter value, advancing the global clock by that amount, and then processing that actor's turn.This fundamental shift allows for "lapping." A highly agile character with low action costs can act multiple times before a slower enemy acts once. This creates a deterministic yet dynamic flow where the player can predict the future state of the battle with perfect accuracy, provided they understand the underlying math. The absence of active time pressure shifts the player's cognitive load from reflex execution to deep forecasting, akin to chess, but with variable piece speeds.11.2 The Deterministic PromiseThe defining feature of FFX’s implementation is its Predictive Timeline UI. Because the math is deterministic (barring randomized damage variance), the system can calculate the turn order for the next infinite number of turns. This visualization is critical. It transforms the mechanics of "Agility" and "Delay" from abstract stats into visible strategic elements. Players do not just "hope" they are faster; they can visually confirm that casting a specific spell will slot them in before the boss’s next attack. Recreating this predictive UI is as essential to the system as the math itself.4Part II: The Mathematical Engine of Final Fantasy XThe FFX model remains the gold standard for pure CTB mathematics. It utilizes a specific interplay between a character's Agility stat, their derived Tick Speed, and the Action Rank of the move they perform.2.1 Agility and the Tick Speed Step-FunctionA common misconception in RPG development is that Speed/Agility should scale linearly (e.g., 50 Agility is twice as fast as 25). FFX avoids this in favor of a Tiered Step-Function. Agility is not used directly in the turn formula; instead, it is converted into a derived integer value called Tick Speed.Tick Speed represents the "base cost" of time for a character. A lower Tick Speed is superior, as it acts as a multiplier for recovery time. The relationship between Agility and Tick Speed is inverse and non-linear, creating distinct "tiers" of power. Players must reach specific Agility thresholds to see any improvement in their turn frequency.Table 1: Agility to Tick Speed Conversion MethodologyThe following table reconstructs the lookup logic used in FFX. Note the significant plateaus where increasing Agility provides no benefit to turn frequency, a critical design consideration for stat progression systems.Agility Stat RangeDerived Tick Speed (TS)Design Tier / Archetype0 – 1612 - 28Lethargic: Reserved for slowest enemies or status-afflicted states.17 – 3411Very Slow: Early game heavy hitters (e.g., Auron).35 – 437Standard: Mid-game baseline.44 – 616Fast: The first major breakpoint for speed-focused builds.62 – 975High Velocity: Late-game standard.98 – 1694Elite: Endgame optimization.170 – 2553Maximum Velocity: The theoretical speed limit.Data synthesized from game mechanics analysis.1Architectural Insight: The "Soft Cap" at 170 Agility is a vital engineering constraint. Once a character reaches 170 Agility, their Tick Speed hits the floor of 3. Increasing Agility to 255 yields zero marginal utility for recurring turns. The only mechanic that utilizes raw Agility beyond 170 is the "Initial Counter Value" (start of battle) calculation. This prevents the game from breaking down into infinite player turns at maximum stats.72.2 Action Rank: The Cost of Doing BusinessIn a standard system, every action might end the turn equally. In CTB, every specific ability in the database acts as a modifier to the recovery time. This is defined by the Action Rank (or Rank).The formula for calculating the "Recovery Time" (the value added to the Counter after acting) is:$$\text{Recovery Counter} = \text{Tick Speed} \times \text{Action Rank}$$This multiplication determines how many Ticks the unit must wait until its next turn.Table 2: Standard Action Ranks in FFXAbility TypeAction RankStrategic ImplicationWeapon/Armor Switch1Extremely fast; often used to manipulate turn order without committing to a full attack.Quick Hit (US Version)1The "Game Breaker." Combined with high Agility, this allows 1:1 tick ratios.Item Use2Faster than attacking; incentivizes item usage for support.Defend2Allows a character to "pass" their turn quickly to a better-positioned ally.Standard Attack3The baseline for all combat balancing.Black Magic3Generally equal to attacking in speed (in FFX).Power Break / Skills4Slower than standard attacks; high commitment.Overdrives4 - 8Massive recovery penalty; using a powerful limit break pushes the user far back in the queue.Data sourced from ability mechanics breakdowns.1Operational Example:Consider a character, Tidus (Agility 45 $\rightarrow$ Tick Speed 6), and a heavy hitter, Auron (Agility 20 $\rightarrow$ Tick Speed 10).Tidus uses "Item" (Rank 2): Recovery $= 6 \times 2 = 12$ Ticks.Auron uses "Attack" (Rank 3): Recovery $= 10 \times 3 = 30$ Ticks.Result: Tidus will recover nearly three times (accumulated 36 ticks) for every single turn Auron takes. This granularity allows for "Speedster" archetypes that deal low damage frequently versus "Tank" archetypes that deal massive damage infrequently.12.3 The Global Tick Decrement LoopThe engine does not run a timer. It runs a loop that subtracts time. When a turn ends, the system must advance to the next event.The Algorithm:State Check: Identify all living units.Minimum Search: Find the unit with the lowest CurrentCounter value ($C_{min}$).Time Warp: Subtract $C_{min}$ from the CurrentCounter of every unit in the battle.The unit that had $C_{min}$ now has 0 (or $\le 0$).All other units are closer to 0 by exactly $C_{min}$.Turn Execution: The unit at 0 becomes the Active Actor. The game state pauses for input.Reset: Once the action is chosen, calculate the new Recovery Counter ($TS \times Rank$) and add it to the actor's current value.Repeat.This subtraction method is computationally efficient and prevents integer overflow that might occur in a system that simply counts "up" indefinitely.1Part III: Temporal Manipulation and Status EffectsThe sophistication of the FFX CTB system lies in how it handles buffs and debuffs. Unlike real-time games where "Slow" might just reduce animation speed or movement velocity, in CTB, these statuses operate as mathematical operators on the Recovery Formula.3.1 Haste and Slow FormulasStatus effects do not change the Tick Speed stats directly; they apply a multiplier to the final Recovery calculation.Haste (Status): Halves the recovery time.$$\text{Counter} = \lfloor \frac{\text{Tick Speed} \times \text{Rank}}{2} \rfloor$$Note: The integer truncation (floor) is crucial. If the base recovery is 9, Haste reduces it to 4, effectively more than halving the wait. This rounding favors the player.11Slow (Status): Doubles the recovery time.$$\text{Counter} = (\text{Tick Speed} \times \text{Rank}) \times 2$$This is a punishing mechanic, effectively deleting half of the victim's turns.113.2 The "Delay" Mechanic"Delay" is a distinct mechanic from "Slow." While Slow affects the rate of future turns, Delay is an instantaneous displacement of the current turn.Mechanism: When a Delay Attack hits, it adds a value directly to the target's CurrentCounter.Formula: Standard Delay attacks often calculate the added value based on the target's Tick Speed, ensuring the delay is proportional.$$\text{Delay Added} \approx \text{Target Tick Speed} \times \text{Delay Power}$$Common Delay Power factors are roughly equivalent to Rank 3 or 4 actions.Visual Result: The player sees the enemy's icon in the UI slide downward, potentially slotting player turns in between the current moment and the enemy's new turn.83.3 The Zombie/Healing ParadoxA fascinating edge case in the FFX engine involves the Zombie status.Normal Behavior: Some abilities (like "Pray" or specific "Regen" ticks) might be coded as "CTB Healing"—reducing the counter to give a turn sooner.Zombie Inversion: The Zombie status inverts healing effects into damage. The FFX engine applies this logic to CTB mechanics as well. If an effect would "Heal" the CTB gauge (reduce the count), the Zombie status inverts this, causing "CTB Damage" (Delay). This effectively means healing a Zombified character delays their turn, a nuanced interaction often overlooked in replication.14Part IV: Initialization and Tie-BreakingHow does the battle begin? And what happens when two units reach 0 at the same time?4.1 Initial Counter Value (ICV)At the start of combat, units are not placed at 0. They are placed at an Initial Counter Value (ICV). This mimics the feeling of "walking into range."Formula: $$\text{ICV} \approx \text{Tick Speed} \times 3 + \text{Random Variance}$$Design Intent: The multiplier (3) ensures that the first turn does not happen immediately at Tick 0, allowing for a staggered start.Pre-emptive Strike: The "Ambush" or "Pre-emptive" state overrides this. The favored side gets ICV = 0 (acting immediately), while the ambushed side suffers a drastically high ICV (essentially a massive Delay).64.2 Deterministic Tie-BreakingIn a discrete integer system, collisions (ties) are inevitable. If Tidus and a Goblin both reach 0 on the same tick, who acts? FFX employs a rigorous priority cascade to resolve this, biased heavily toward the player to prevent frustration.Priority Cascade Protocol:Counter Value: The unit with the "most negative" counter goes first (if the subtraction pushed them below 0).Affiliation: Player Character > Enemy Character. The player always wins a true tie.Party Index: Slot 1 (Top) > Slot 2 > Slot 3.Entity ID: Internal database index (for enemy-vs-enemy resolution).This strict hierarchy ensures the "Predictive UI" never flickers or guesses. The outcome is known 100% of the time.4Part V: The Hybrid Paradigm: Clair Obscur: Expedition 33While FFX represents the pure mathematical implementation, Clair Obscur: Expedition 33 introduces a "Hybrid Turn-Based Real-Time" architecture. It retains the CTB timeline for strategy but injects skill-based execution phases that disrupt the deterministic outcome.5.1 The Reaction Phase InjectionIn FFX, when an enemy takes a turn, the player is a passive observer. In Expedition 33, the Enemy Turn is an interactive phase.The Parry/Dodge Mechanic:State Implementation: When the Enemy acts, the game enters a ReactionState. The timeline pauses, and the enemy animation plays.Hit Windows: The engine defines specific frame ranges within the enemy's attack animation as "Parry Frames" or "Dodge Frames."Outcome Branching:Failure: Standard damage calculation.Perfect Parry: Damage is negated (reduced to 0). The player character triggers a Counter-Attack.Perfect Dodge: Damage is negated. No Counter-Attack is triggered.System Impact: A Counter-Attack is effectively a "Free Action." It allows the player to deal damage during the enemy's turn without spending their own CTB turns or AP. This disrupts the balance of the standard CTB economy, effectively rewarding mechanical skill with "bonus turns".185.2 Audio-Visual SynchronizationResearch indicates that Expedition 33 tightly couples its parry windows to the audio track. The enemy attack animations are often rhythmic, syncing with the background music's BPM.Engineering Note: Implementing this requires the Battle Engine to be time-synced with the Audio Engine. The "Parry Window" is likely defined not just by animation frames but by AudioSource.time or beat markers. This provides an auditory cue for the player, reinforcing the "rhythm" of combat.205.3 The AP Economy and Gradient AttacksExpedition 33 replaces the FFX MP system with Action Points (AP) and introduces Gradient Attacks.AP Regeneration: AP is regenerated per turn, but crucially, it is also regenerated via successful Parries. This creates a feedback loop: Skillful defense (Parry) fuels offensive resources (AP).Gradient Attacks: These are charged abilities that allow a "Play Again" mechanic.Mechanic: Using a Gradient Attack often does not reset the character's CTB Counter immediately or resets it with a very low Rank.Constraint: To prevent infinite loops, the system enforces a hard cap (e.g., "Play Again" can only trigger once per turn sequence). The code must track a ChainCount variable; if ChainCount >= 1, the next action forces a full turn reset regardless of the ability used.185.4 Turn Order AnomaliesUsers report that Expedition 33 behaves inconsistently regarding the First Turn. Unlike FFX’s randomized ICV, Expedition 33 appears to default to Party Order (Slot 1, then Slot 2, then Slot 3) for the initial round, ignoring Speed stats unless a specific "First Strike" passive is equipped.Design Critique: This is likely a simplification of the initialization code (setting ICV based on index rather than Agility). For a robust recreation, it is recommended to stick to the FFX model (Agility-based ICV) to ensure fast characters feel fast immediately, rather than waiting for the second cycle.22Part VI: Architectural Blueprint (How to Build It)This section details the software architecture required to implement a generic CTB system. This design is agnostic to the engine (Unity, Unreal, Godot) but assumes an Object-Oriented approach.6.1 Core Class Structures1. BattleUnit ClassThis class encapsulates the state of a single participant.C#class BattleUnit {
    int Agility;
    int CurrentCounter;
    int TickSpeed; // Cached value updated when Agility changes
    bool IsPlayer;
    int PartyIndex; // For tie-breaking
    
    void UpdateTickSpeed() {
        // Implementation of the Table 1 Lookup
        TickSpeed = LookupTable.GetTickSpeed(this.Agility);
    }
    
    void OnTurnComplete(ActionAbility ability) {
        int recovery = this.TickSpeed * ability.Rank;
        
        // Status Effect Logic
        if (HasStatus("Haste")) recovery = floor(recovery / 2);
        if (HasStatus("Slow")) recovery = recovery * 2;
        
        this.CurrentCounter += max(1, recovery);
    }
}
2. BattleManager Class (The Singleton)This manages the global state and the "Game Loop."C#class BattleManager {
    List<BattleUnit> AllUnits;
    
    void ProcessNextTurn() {
        // 1. Find Min Counter
        int minTicks = AllUnits.Min(u => u.CurrentCounter);
        
        // 2. Decrement All
        foreach(var unit in AllUnits) {
            unit.CurrentCounter -= minTicks;
        }
        
        // 3. Find Active Unit (Tie-Breaker Logic)
        var activeUnit = AllUnits
           .Where(u => u.CurrentCounter <= 0)
           .OrderBy(u => u.CurrentCounter) // Most negative first
           .ThenByDescending(u => u.IsPlayer) // Player priority
           .ThenBy(u => u.PartyIndex) // Slot priority
           .First();
            
        // 4. Trigger Turn State
        StartCoroutine(ExecuteTurn(activeUnit));
    }
}
6.2 The Prediction Algorithm (The UI)The "Act List" UI requires a simulation that runs parallel to the actual game state without modifying it. This is the most computationally expensive part of a CTB system.Algorithm: The Ghost SimulationDeep Copy: Create a temporary list of BattleUnit clones. Copy their current CurrentCounter, TickSpeed, and Status Effects.Simulation Loop: Run the ProcessNextTurn logic on the clones.Assumption: When a clone takes a turn, assume they use a standard Rank 3 action (Attack). This is the baseline prediction.Record & Repeat: Each time a clone reaches 0, add its ID to a PredictedTurnOrder list. Apply the Rank 3 recovery to the clone and continue the loop.Termination: Stop when the list has $N$ entries (e.g., 10 or 16).Dynamic Preview: If the player highlights a specific ability (e.g., "Quick Hit", Rank 1) in the menu:Re-run the simulation.For the first instance of the player's clone acting, use Rank 1 instead of Rank 3.This will show the player's portrait appearing sooner in the subsequent timeline, visually communicating the benefit of the speed ability.46.3 Handling "Infinite Turn" LoopsA common implementation bug occurs when a unit's speed is so high that they take multiple turns in a row.The Issue: If TickSpeed * Rank is very low (e.g., 2), and the opponent is at Counter 50.Correct Behavior: The simulation loop decrements 2 ticks. The player is at 0 again. The opponent is at 48. The player acts. The loop repeats.UI Representation: The UI must be capable of showing the same character portrait 5, 6, or 10 times in a row before the enemy appears. This visual feedback is immensely satisfying to the player and confirms the power of their build.Part VII: Design & Balance Recommendations7.1 Balancing the Agility CurveAvoid linear Agility scaling. If Agility 50 is twice as fast as Agility 25, the stat becomes too granular and hard to balance.Recommendation: Adopt the FFX Tiered System. It creates clear goals for the player. "I need 4 more Agility to reach the next breakpoint." This makes gear choices more meaningful.7.2 The "Parry God" ProblemIn Expedition 33, players noted that mastering the Parry made defensive stats (HP, Defense) obsolete. If you take 0 damage, you don't need Armor.Balance Fix:Chip Damage: Make Parries reduce damage by 80% rather than 100%, keeping HP relevant.Stamina Cost: Require a resource to Parry, preventing spam against multi-hit combos.Unparryable Attacks: Introduce "Red Flash" attacks that must be Dodged or Tanked, not Parried, forcing interaction with the full mechanics suite.197.3 Haste DominanceIn CTB, Haste is historically the most powerful buff because it doubles action economy.Adjustment: Consider making Haste a 1.5x multiplier (33% reduction in recovery) rather than 2x, or giving enemies access to "Dispel" mechanics to punish over-reliance on buffs.ConclusionThe Conditional Turn-Based system remains one of the most elegant solutions in RPG design. It offers the strategic depth of chess with the pacing of a cinematic brawl. By combining the rigid integer mathematics of Final Fantasy X—Tick Speeds, Action Ranks, and Deterministic Queues—with the visceral, reactive layers of Expedition 33, a developer can create a combat system that is both intellectually satisfying and mechanically engaging. The blueprint provided here offers the structural integrity required to build such a system, scalable from a simple indie prototype to a complex AAA RPG.